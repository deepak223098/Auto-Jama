"""
+------------------------------------------------------------------------------+
|                       Copyright 2017 Rockwell Collins                        |
|                             All Rights Reserved                              |
|                           Proprietary Information                            |
+------------------------------------------------------------------------------+

Utility functions for executing a subprocess
"""
import json
import logging
import os
import subprocess
import sys
import threading
import time
from distutils import spawn

import files
from constants import RESOURCES_DIR


__version__ = '$Rev: 243456 $'


class ExecuteException(Exception):
    """Exception for failed process execution"""
    def __init__(self, exit_code, *args, **kwargs):
        """
        Creates the exception.

        :param exit_code: the exit code generated by the process.
        :type  exit_code: int
        """
        super(ExecuteException, self).__init__(
            kwargs.pop(
                'message',
                'Process failed with exit code {}.'.format(exit_code)),
            *args, **kwargs)

        self.exit_code = exit_code


class MissingExecutable(Exception):
    """Exception for a missing executable"""
    pass


def execute(command, cwd=None, env=None, shell=False):
    """
    Executes a command in a subprocess.

    :param command: command to execute
    :type  command: basestring
    :param cwd: directory to execute from
    :type  cwd: basestring
    :param env: environment variables to use for the subprocess
    :type  env: dict
    :param shell: whether to run in the OS shell
    :type  shell: bool
    """
    if env is None:
        env = os.environ.copy()

    logging.debug(command)
    result = subprocess.Popen(
        command,
        cwd=cwd,
        env=env,
        shell=shell,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE).wait()

    if result != 0:
        logging.error('Command "{}" failed!'.format(command))
        raise ExecuteException(result)


def execute_with_log(command, log, cwd=None, env=None, shell=False):
    """
    Executes a command in a subprocess and saves the output to a log file.

    :param command: command to execute
    :type  command: basestring
    :param log: name of the file to save output to
    :type  log: basestring
    :param cwd: directory to execute from
    :type  cwd: basestring
    :param env: environment variables to use for the subprocess
    :type  env: dict
    :param shell: whether to run in the OS shell
    :type  shell: bool
    """
    if env is None:
        env = os.environ.copy()

    logging.debug(command)
    logging.debug('Output logged at "{}"'.format(log))
    with open(log, 'w') as out:
        result = subprocess.Popen(
            command,
            cwd=cwd,
            env=env,
            shell=shell,
            stdout=out,
            stderr=out).wait()

    if result != 0:
        logging.error('Command "{cmd}" failed! See "{log}" for details.'.format(
            cmd=command,
            log=log))

        raise ExecuteException(result)


def communicate(command, stdin=None, cwd=None, env=None, shell=False):
    """
    Executes a command in a subprocess with the given input.

    :param command: command to execute
    :type  command: basestring
    :param stdin: input to use as stdin
    :type  stdin: basestring
    :param cwd: directory to execute from
    :type  cwd: basestring
    :param env: environment variables to use for the subprocess
    :type  env: dict
    :param shell: whether to run in the OS shell
    :type  shell: bool
    :return: output from stdout and stderr
    :rtype: tuple(basestring, basestring)
    """
    if env is None:
        env = os.environ.copy()

    logging.debug(command)
    proc = subprocess.Popen(
        command,
        cwd=cwd,
        env=env,
        shell=shell,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)

    out, err = proc.communicate(stdin)
    result = proc.wait()

    if result != 0:
        logging.error('Command "{}" failed!'.format(command))
        raise ExecuteException(result)

    return out, err


def get_exec(executable, default):
    """
    Get the full path to an executable on PATH.

    :param executable: the executable to find on PATH
    :type  executable: basestring
    :param default: the path to use if the executable is not found on PATH
    :type  default: basestring or list[basestring]
    :return: the full path to the executable
    :rtype: basestring
    """
    path = spawn.find_executable(executable)
    if path is not None:
        return path

    if not isinstance(default, (list, tuple, set)):
        default = [default]

    for d in default:
        try:
            return files.real_file(d)

        except files.PathNotFoundException:
            pass

    raise MissingExecutable(
        'Executable not found on PATH or at "{}".'.format(
            '" or "'.join(default)))


def batch_environment(batch_script, *batch_args):
    """
    Executes a batch file and collects the environment variable values set by
    it.

    :param batch_script: path to the batch script to execute
    :type  batch_script: basestring
    :param batch_args: arguments to call the batch script with
    :return: environment variables set by the batch script
    :rtype: dict{basestring: basestring}
    """
    batch_dir, batch_file = os.path.split(files.real_file(batch_script))
    command = '"{script}" "{batch_file}"'.format(
        script=os.path.join(RESOURCES_DIR, 'batch_env.bat'),
        batch_file=batch_file)

    for arg in batch_args:
        command = '{cmd} {arg}'.format(cmd=command, arg=arg)

    out, err = communicate(
        command,
        cwd=batch_dir,
        env={'PYTHON_BIN': sys.executable},
        shell=True)

    return json.loads(out)


class ExceptionThread(threading.Thread):
    """Thread that saves the exception if it generates one"""
    def __init__(self, *args, **kwargs):
        """
        Constructor called in instantiation. Prepares a thread that can save
        exceptions.
        """
        threading.Thread.__init__(self, *args, **kwargs)
        self.exception = None
        self._run = self.run
        self.run = self._run_wrapper

    def _run_wrapper(self):
        """
        Executes normally and saves any exceptions.
        """
        try:
            self._run()

        except:
            self.exception = sys.exc_info()

    def join(self, *args, **kwargs):
        """
        Blocks until the thread has finished executing.
        """
        threading.Thread.join(self, *args, **kwargs)
        if self.exception is not None:
            logging.error('Encountered an exception while in a thread!')
            raise self.exception[0], self.exception[1], self.exception[2]


class KeyLocker(object):
    """Interface for creating thread locks based on keys"""
    _locks = {}
    _locks_lock = threading.Lock()

    class KeyLock(object):
        """Interface for a thread lock associated with a key"""
        def __init__(self, key):
            """
            Constructor called in instantiation.  Creates a lock for an 
            associated key.
            """
            self._key = key

        def __enter__(self):
            """
            Acquires the associated lock when it becomes available (threadsafe).

            Called on "with" entry:
            >>> with KeyLocker.lock('example-key'):
            >>>     # do stuff (locked)
            >>>
            >>> # do stuff (not locked)
            """
            has_lock = False
            while not has_lock:
                KeyLocker._locks_lock.acquire()
                lock = KeyLocker._locks.get(self._key)
                if lock is None:
                    lock = threading.Lock()
                    KeyLocker._locks[self._key] = lock

                has_lock = lock.acquire(False)
                KeyLocker._locks_lock.release()
                if not has_lock:
                    time.sleep(0.1)

        def __exit__(self, *args, **kwargs):
            """
            Releases the associated lock.  Called on "with" exit.
            """
            lock = KeyLocker._locks.get(self._key)
            if lock is None:
                return

            lock.release()

    @classmethod
    def lock(cls, key):
        """
        Acquires a thread lock for an associated key.
        """
        return cls.KeyLock(key)
